---
name: staleness-detection
description: 코드 변경 후 문서 노후화를 체계적으로 감지하는 방법
---

# 문서 노후화 감지 가이드

이 Skill은 문서화 에이전트가 코드 변경 후 기존 문서의 정확성을 검증하는 방법을 제공합니다.

## 목적

코드가 변경되면 문서가 노후화됩니다. 이 스킬은 **어떤 문서가, 왜 노후화되었는지** 체계적으로 감지합니다.

---

## 감지 프로세스

### 1단계: 변경 범위 파악

```bash
# 최근 N개 커밋의 변경 파일 목록
git log --oneline -N --name-status

# 특정 커밋 범위의 변경
git diff --name-only <base>..HEAD
```

변경 파일을 카테고리로 분류합니다:

| 변경 유형 | 문서 영향 | 우선순위 |
|---|---|---|
| API 시그니처 변경 (함수 파라미터/반환타입) | README API 섹션 노후화 | **P0** |
| import 경로 변경 (`@/` → `#`) | 모든 코드 예제 노후화 | **P0** |
| 파일명/경로 변경 | 프로젝트 구조 섹션 노후화 | **P1** |
| 의존성 추가/제거 | 기술 스택 섹션 노후화 | **P1** |
| 새 기능 추가 | README에 기능 설명 누락 | **P2** |
| 설정 파일 변경 | 개발 가이드 노후화 | **P2** |
| 코드 포매팅/린트만 | 문서 영향 없음 | **스킵** |
| 테스트만 추가 | 문서 영향 없음 (테스트 섹션 제외) | **스킵** |

### 2단계: 문서별 검증 항목

#### README.md 검증

각 README에서 다음을 대조합니다:

**A. import 경로 검증**

```
검증 방법:
1. README 내 import 문 추출 (코드 블록 내 `import ... from '...'`)
2. 실제 파일에서 같은 모듈의 import 문 확인
3. 경로가 다르면 → 노후화
```

예시:
- 문서: `import { parseEcountUrl } from '@/services/url_service'`
- 실제: `import { parseEcountUrl } from '#services/url_service'`
- 결과: **노후화 (P0)**

**B. API 시그니처 검증**

```
검증 방법:
1. README의 함수 시그니처 추출
2. 실제 소스에서 export된 함수 시그니처 확인
3. 파라미터 수/타입/반환타입이 다르면 → 노후화
```

예시:
- 문서: `buildEc5Url(base_url: string, server_config: ServerConfig): string`
- 실제: `buildEc5Url(current_url: URL, to_v5_server: string, to_v3_server: string): string`
- 결과: **노후화 (P0)**

**C. 타입 정의 검증**

```
검증 방법:
1. README의 타입/인터페이스 정의 추출
2. 실제 타입 파일과 대조
3. 속성 추가/제거/변경이 있으면 → 노후화
```

**D. 프로젝트 구조 검증**

```
검증 방법:
1. README의 디렉토리 트리에서 파일/폴더 목록 추출
2. 실제 파일 시스템과 대조
3. 존재하지 않는 파일이 있거나 새 파일이 누락되면 → 노후화
```

**E. 기술 스택/의존성 검증**

```
검증 방법:
1. README의 기술 스택 섹션에서 패키지 목록 추출
2. package.json의 실제 의존성과 대조
3. 추가/제거된 패키지가 있으면 → 노후화
```

#### 에이전트 스킬 파일 검증

스킬 파일(`.agents/skills/**/references/*.md`, `.cursor/skills/**/SKILL.md`)은 코드 예제와 패턴이 포함되므로 코드 변경에 민감합니다.

```
검증 방법:
1. 스킬 파일 내 코드 블록에서 import 경로 추출
2. 스킬에서 참조하는 라이브러리/addon이 package.json에 존재하는지 확인
3. 스킬의 "권장" 패턴이 실제 프로젝트 패턴과 일치하는지 확인
```

예시:
- 스킬: `@storybook/addon-svelte-csf`의 `defineMeta` 사용을 권장
- 실제: addon 제거됨, CSF3 `.stories.ts`만 사용
- 결과: **노후화 (P0) - 에이전트가 빌드 실패 코드 생성**

### 3단계: 노후화 리포트 생성

감지된 노후화를 다음 형식으로 정리합니다:

```markdown
## 문서 노후화 리포트

### P0 (즉시 수정)
| 문서 | 위치 | 노후화 내용 | 원인 커밋 |
|---|---|---|---|
| ecount-dev-tool/README.md | API 섹션 | import 경로 `@/` → `#` 미반영 | abc1234 |
| storybook-strategy.md | 전체 | 제거된 addon을 권장 | def5678 |

### P1 (다음 작업 시)
| 문서 | 위치 | 노후화 내용 |
|---|---|---|
| README.md | 프로젝트 구조 | test/ 디렉토리 누락 |

### P2 (선택적)
| 문서 | 위치 | 노후화 내용 |
|---|---|---|
| README.md | 기술 스택 | Storybook 10 미언급 |
```

---

## 자동 감지 트리거

다음 변경 패턴 감지 시 문서 검증을 권장합니다:

| 패턴 | 감지 방법 | 영향 범위 |
|---|---|---|
| import 경로 체계 변경 | `git diff`에서 import 문 대량 변경 | 모든 코드 예제 |
| 패키지 추가/제거 | `package.json` diff | 기술 스택, 설치 가이드 |
| 함수 시그니처 변경 | export 함수의 파라미터 변경 | API 문서 |
| 파일/폴더 구조 변경 | 파일 rename/move/delete | 프로젝트 구조 섹션 |
| 설정 파일 변경 | `tsconfig`, `vite.config` 등 | 개발 가이드 |
| 테스트 전략 변경 | `.test.ts` 대량 삭제/생성 | 테스트 섹션 |

---

## 스킬 파일 노후화의 특수성

스킬 파일은 일반 문서보다 노후화 영향이 큽니다:
- 일반 문서 노후화 → 개발자가 잘못된 정보를 봄
- **스킬 파일 노후화 → 에이전트가 잘못된 코드를 생성함**

따라서 스킬 파일의 노후화 감지 우선순위가 더 높습니다.

### 스킬 검증 체크리스트

- [ ] 스킬에서 참조하는 패키지가 `package.json`/`pnpm-workspace.yaml`에 존재하는가?
- [ ] 스킬의 코드 예제가 현재 프로젝트에서 실행 가능한가?
- [ ] 스킬의 "권장" 패턴이 프로젝트의 실제 패턴과 일치하는가?
- [ ] 스킬에서 참조하는 파일 경로가 실제로 존재하는가?
- [ ] 스킬의 import 경로가 현재 프로젝트의 경로 체계와 일치하는가?

---

## 완료 기준

- [ ] 변경 범위에 해당하는 모든 문서 식별
- [ ] P0 노후화 항목 0개 (모두 수정)
- [ ] P1 노후화 항목 리포트 작성
- [ ] 스킬 파일 검증 완료
