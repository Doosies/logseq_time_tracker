---
name: code-vulnerability-scan
description: 코드 보안 취약점 (SQL Injection, XSS, CSRF 등) 스캔 가이드
---

# 코드 보안 취약점 스캔 가이드

이 Skill은 Security 에이전트가 코드에서 보안 취약점을 탐지할 때 사용합니다.

## 취약점 유형

### 1. SQL Injection
### 2. XSS (Cross-Site Scripting)
### 3. CSRF (Cross-Site Request Forgery)
### 4. 안전하지 않은 함수 사용
### 5. 안전하지 않은 역직렬화
### 6. Path Traversal
### 7. 전역 Prototype 오염 (Prototype Pollution)
### 8. Command Injection

---

## 1. SQL Injection

### 취약 패턴

```typescript
// ❌ 위험: 사용자 입력이 직접 SQL 쿼리에 삽입
async function getUser(email: string) {
  const query = `SELECT * FROM users WHERE email = '${email}'`;
  return await db.query(query);
}

// 공격 예시: email = "' OR '1'='1"
// 결과: SELECT * FROM users WHERE email = '' OR '1'='1'
// 모든 사용자 정보 유출!
```

### 탐지 패턴

```typescript
const sql_injection_patterns = [
  // 템플릿 리터럴로 SQL 쿼리 생성
  /`\s*(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER)\s+.*\$\{/i,
  
  // 문자열 연결로 SQL 쿼리 생성
  /(SELECT|INSERT|UPDATE|DELETE)\s+.*\+\s*\w+/i,
  
  // 직접 사용자 입력을 쿼리에 삽입
  /\.(query|execute)\s*\(\s*['"`].*\$\{/i,
];

function detectSQLInjection(code: string): boolean {
  return sql_injection_patterns.some(pattern => pattern.test(code));
}
```

### 안전한 코드

```typescript
// ✅ 안전: Prepared Statement 사용
async function getUser(email: string) {
  const query = 'SELECT * FROM users WHERE email = ?';
  return await db.query(query, [email]);
}

// ✅ 안전: ORM 사용
async function getUser(email: string) {
  return await User.findOne({ where: { email } });
}
```

---

## 2. XSS (Cross-Site Scripting)

### 취약 패턴

```typescript
// ❌ 위험: 사용자 입력을 직접 HTML에 삽입
function renderProfile(username: string) {
  return `<div>Hello, ${username}!</div>`;
}

// 공격 예시: username = "<script>alert('XSS')</script>"
// 결과: 스크립트 실행됨
```

### 탐지 패턴

```typescript
const xss_patterns = [
  // innerHTML에 직접 대입
  /\.innerHTML\s*=\s*[^'"`]*\$\{/,
  
  // outerHTML에 직접 대입
  /\.outerHTML\s*=\s*[^'"`]*\$\{/,
  
  // 템플릿 리터럴로 HTML 생성
  /`<[^>]*>\s*\$\{/,
  
  // dangerouslySetInnerHTML 사용 (React)
  /dangerouslySetInnerHTML\s*=\s*\{\{/,
];

function detectXSS(code: string): boolean {
  return xss_patterns.some(pattern => pattern.test(code));
}
```

### 안전한 코드

```typescript
// ✅ 안전: 이스케이프 함수 사용
function escapeHtml(text: string): string {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

function renderProfile(username: string) {
  const safe_username = escapeHtml(username);
  return `<div>Hello, ${safe_username}!</div>`;
}

// ✅ 안전: React (기본적으로 이스케이프됨)
function Profile({ username }: { username: string }) {
  return <div>Hello, {username}!</div>;
}
```

---

## 3. CSRF (Cross-Site Request Forgery)

### 취약 패턴

```typescript
// ❌ 위험: CSRF 토큰 없이 중요한 작업 수행
app.post('/api/delete-account', async (req, res) => {
  await User.delete(req.user.id);
  res.json({ success: true });
});

// 공격 예시: 악의적인 사이트에서 form 자동 제출
// <form action="https://target.com/api/delete-account" method="POST">
//   <input type="submit" value="Click me!">
// </form>
```

### 탐지 패턴

```typescript
const csrf_vulnerable_patterns = [
  // POST/PUT/DELETE 요청에 CSRF 토큰 검증 없음
  /(app|router)\.(post|put|delete)\s*\(\s*['"][^'"]*['"]\s*,\s*(?!.*csrf)/i,
];

function detectCSRFVulnerability(code: string): boolean {
  return csrf_vulnerable_patterns.some(pattern => pattern.test(code));
}
```

### 안전한 코드

```typescript
// ✅ 안전: CSRF 토큰 검증
import csrf from 'csurf';

const csrfProtection = csrf({ cookie: true });

app.post('/api/delete-account', csrfProtection, async (req, res) => {
  // CSRF 토큰이 검증됨
  await User.delete(req.user.id);
  res.json({ success: true });
});

// 클라이언트에서 토큰 포함
// fetch('/api/delete-account', {
//   method: 'POST',
//   headers: { 'CSRF-Token': csrfToken },
// });
```

---

## 4. 안전하지 않은 함수 사용

### 취약 패턴

```typescript
// ❌ 위험: eval() 사용
function calculate(expression: string) {
  return eval(expression);
}

// 공격 예시: expression = "process.exit(1)"
// 결과: 서버 다운

// ❌ 위험: Function 생성자
const fn = new Function('user_input', 'return ' + user_input);

// ❌ 위험: child_process.exec with user input
exec(`ls ${user_input}`);
```

### 탐지 패턴

```typescript
const unsafe_function_patterns = [
  /\beval\s*\(/,
  /new\s+Function\s*\(/,
  /setTimeout\s*\(\s*['"][^'"]*\$\{/,
  /setInterval\s*\(\s*['"][^'"]*\$\{/,
  /exec\s*\(\s*['"`][^'"`]*\$\{/,
  /execSync\s*\(\s*['"`][^'"`]*\$\{/,
];

function detectUnsafeFunctions(code: string): boolean {
  return unsafe_function_patterns.some(pattern => pattern.test(code));
}
```

### 안전한 코드

```typescript
// ✅ 안전: 수식 파싱 라이브러리 사용
import { evaluate } from 'mathjs';

function calculate(expression: string) {
  try {
    return evaluate(expression);
  } catch (error) {
    throw new ValidationError('Invalid expression');
  }
}

// ✅ 안전: child_process.execFile with array
import { execFile } from 'child_process';

execFile('ls', [user_input]); // 배열로 전달하면 안전
```

---

## 5. 안전하지 않은 역직렬화

### 취약 패턴

```typescript
// ❌ 위험: 신뢰할 수 없는 데이터를 역직렬화
function processData(json_string: string) {
  const data = JSON.parse(json_string);
  return data;
}

// ❌ 위험: eval을 이용한 역직렬화 (더 위험)
const obj = eval('(' + user_input + ')');
```

### 탐지 패턴

```typescript
const unsafe_deserialization_patterns = [
  /JSON\.parse\s*\(\s*(?!.*validate)/,
  /eval\s*\(\s*['"`]\(/,
];

function detectUnsafeDeserialization(code: string): boolean {
  return unsafe_deserialization_patterns.some(pattern => pattern.test(code));
}
```

### 안전한 코드

```typescript
// ✅ 안전: 스키마 검증 후 역직렬화
import { z } from 'zod';

const UserSchema = z.object({
  name: z.string(),
  email: z.string().email(),
  age: z.number().min(0).max(150),
});

function processData(json_string: string) {
  const data = JSON.parse(json_string);
  
  // 스키마 검증
  const validated = UserSchema.parse(data);
  
  return validated;
}
```

---

## 6. Path Traversal

### 취약 패턴

```typescript
// ❌ 위험: 사용자 입력으로 파일 경로 생성
app.get('/download', (req, res) => {
  const filename = req.query.file;
  const file_path = `/uploads/${filename}`;
  res.sendFile(file_path);
});

// 공격 예시: file = "../../etc/passwd"
// 결과: /uploads/../../etc/passwd → /etc/passwd 접근 가능
```

### 탐지 패턴

```typescript
const path_traversal_patterns = [
  /\/(uploads?|files?|static)\/\s*\$\{/i,
  /path\.join\s*\([^)]*\$\{/,
  /fs\.readFile\s*\([^)]*\$\{/,
  /fs\.writeFile\s*\([^)]*\$\{/,
];

function detectPathTraversal(code: string): boolean {
  return path_traversal_patterns.some(pattern => pattern.test(code));
}
```

### 안전한 코드

```typescript
// ✅ 안전: 경로 검증
import path from 'path';

app.get('/download', (req, res) => {
  const filename = req.query.file as string;
  
  // 1. '..' 제거
  const safe_filename = path.basename(filename);
  
  // 2. 허용된 디렉토리 내부인지 확인
  const uploads_dir = path.resolve('/uploads');
  const file_path = path.resolve(uploads_dir, safe_filename);
  
  if (!file_path.startsWith(uploads_dir)) {
    return res.status(400).json({ error: 'Invalid file path' });
  }
  
  res.sendFile(file_path);
});
```

---

## 8. 전역 Prototype 오염 (Prototype Pollution)

### 취약 패턴

```typescript
// ❌ 위험: Object.prototype에 속성 추가 (테스트 setup 등에서)
Object.defineProperty(Object.prototype, 'tagName', {
  get() { return this.nodeName || ''; },
  configurable: true
});

// 결과: @testing-library, userEvent 등 DOM 상호작용 완전히 깨짐
// 모든 객체에서 .tagName 접근 시 예상치 못한 동작
```

### 탐지 패턴

```typescript
const prototype_pollution_patterns = [
  // Object.prototype 수정
  /Object\.defineProperty\s*\(\s*Object\.prototype\s*,/,
  /Object\.prototype\.\w+\s*=/,
  /Object\.assign\s*\(\s*Object\.prototype\s*,/,
  
  // Array.prototype 수정
  /Array\.prototype\.\w+\s*=/,
  /Object\.defineProperty\s*\(\s*Array\.prototype\s*,/,
  
  // 기타 built-in prototype
  /\w+\.prototype\.\w+\s*=\s*function/,
];

function detectPrototypePollution(code: string): boolean {
  return prototype_pollution_patterns.some(pattern => pattern.test(code));
}
```

### 안전한 코드

```typescript
// ✅ 안전: 특정 모듈/객체에만 모킹 적용
const mock_element = {
  tagName: 'DIV',
  getAttribute: (name: string) => mock_attrs[name],
};

// ✅ 안전: 해당 모듈 경계 내에서만 patch
// 테스트 대상이 아닌 jsdom/라이브러리 이슈는 해당 라이브러리 모킹으로 해결
```

---

## 9. Command Injection

### 취약 패턴

```typescript
// ❌ 위험: 사용자 입력이 직접 명령어에 삽입
import { exec } from 'child_process';

function ping(host: string) {
  exec(`ping -c 4 ${host}`, (error, stdout) => {
    console.log(stdout);
  });
}

// 공격 예시: host = "google.com; rm -rf /"
// 결과: ping -c 4 google.com; rm -rf /
```

### 탐지 패턴

```typescript
const command_injection_patterns = [
  /exec\s*\(\s*['"`][^'"`]*\$\{/,
  /execSync\s*\(\s*['"`][^'"`]*\$\{/,
  /spawn\s*\(\s*['"`][^'"`]*\$\{/,
];

function detectCommandInjection(code: string): boolean {
  return command_injection_patterns.some(pattern => pattern.test(code));
}
```

### 안전한 코드

```typescript
// ✅ 안전: execFile with array
import { execFile } from 'child_process';

function ping(host: string) {
  // 호스트 검증
  if (!/^[a-zA-Z0-9.-]+$/.test(host)) {
    throw new ValidationError('Invalid host');
  }
  
  // 배열로 전달 (인젝션 불가능)
  execFile('ping', ['-c', '4', host], (error, stdout) => {
    console.log(stdout);
  });
}
```

---

## 종합 스캔 함수

```typescript
interface VulnerabilityDetection {
  file_path: string;
  line_number: number;
  type: 'sql_injection' | 'xss' | 'csrf' | 'unsafe_function' | 
        'unsafe_deserialization' | 'path_traversal' | 'prototype_pollution' | 'command_injection';
  severity: 'critical' | 'high' | 'medium';
  description: string;
  recommendation: string;
}

function scanCodeVulnerabilities(
  code: string,
  file_path: string
): VulnerabilityDetection[] {
  const vulnerabilities: VulnerabilityDetection[] = [];
  const lines = code.split('\n');
  
  lines.forEach((line, index) => {
    const line_number = index + 1;
    
    // SQL Injection
    if (detectSQLInjection(line)) {
      vulnerabilities.push({
        file_path,
        line_number,
        type: 'sql_injection',
        severity: 'critical',
        description: 'SQL Injection 취약점 발견',
        recommendation: 'Prepared Statement 또는 ORM 사용',
      });
    }
    
    // XSS
    if (detectXSS(line)) {
      vulnerabilities.push({
        file_path,
        line_number,
        type: 'xss',
        severity: 'high',
        description: 'XSS 취약점 발견',
        recommendation: '사용자 입력을 이스케이프하거나 안전한 렌더링 사용',
      });
    }
    
    // Unsafe Functions
    if (detectUnsafeFunctions(line)) {
      vulnerabilities.push({
        file_path,
        line_number,
        type: 'unsafe_function',
        severity: 'critical',
        description: '안전하지 않은 함수 사용 (eval, exec 등)',
        recommendation: '안전한 대안 사용 (파싱 라이브러리, execFile 등)',
      });
    }
    
    // Path Traversal
    if (detectPathTraversal(line)) {
      vulnerabilities.push({
        file_path,
        line_number,
        type: 'path_traversal',
        severity: 'high',
        description: 'Path Traversal 취약점 발견',
        recommendation: '경로 검증 및 path.basename() 사용',
      });
    }
    
    // Prototype Pollution
    if (detectPrototypePollution(line)) {
      vulnerabilities.push({
        file_path,
        line_number,
        type: 'prototype_pollution',
        severity: 'critical',
        description: '전역 prototype 오염 (Object.prototype, Array.prototype 등 수정)',
        recommendation: 'built-in prototype 수정 절대 금지. 특정 모듈/객체에만 모킹 적용',
      });
    }
    
    // Command Injection
    if (detectCommandInjection(line)) {
      vulnerabilities.push({
        file_path,
        line_number,
        type: 'command_injection',
        severity: 'critical',
        description: 'Command Injection 취약점 발견',
        recommendation: 'execFile with array 사용',
      });
    }
  });
  
  return vulnerabilities;
}
```

---

## 체크리스트

코드 보안 취약점 스캔 시:

- [ ] SQL Injection 패턴 검사
- [ ] XSS 패턴 검사
- [ ] CSRF 토큰 사용 확인
- [ ] eval(), exec() 사용 확인
- [ ] 안전하지 않은 역직렬화 확인
- [ ] Path Traversal 방어 확인
- [ ] **전역 Prototype 오염 검사** (Object.prototype, Array.prototype 수정 금지 - 테스트 setup 포함)
- [ ] Command Injection 방어 확인

---

## 완료 기준

- [ ] 모든 소스 파일 스캔 완료
- [ ] Critical 취약점 0개
- [ ] High 취약점 해결 또는 위험 수용
- [ ] 권장 수정 사항 문서화
- [ ] 로그 기록 완료
